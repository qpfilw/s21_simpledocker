## Part 1. Готовый докер

Возьмем официальный докер-образ с nginx и выкачаем его при помощи `docker pull`.

![1.png](image/1.png)
>Скачивание образа

Проверим наличие докер-образа через `docker images`.

![2.png](image/2.png)
>Проверка наличия докер-образа

Запустим докер-образ через `docker run -d [image_id|repository]`.

![3.png](image/3.png)
>Запуск докер-образа

Проверим, что образ запустился через `docker ps`.

![4.png](image/4.png)
>Проверка запуска

Посмотрим информацию о контейнере через `docker inspect [container_id|container_name]`. По выводу команды определим:
- размер контейнера = 81920. `SizeRootFs`: общий размер всех файлов в контейнере в байтах. `SizeRw`: размер файлов, которые были созданы или изменены в контейнере, по сравнению с его изображением, в байтах

![5.png](image/5.png)

- список замапленных портов = 0.

![6.png](image/6.png)

- ip контейнера = 172.17.0.2

![7.png](image/7.png)

Остановим докер контейнер через `docker stop [container_id|container_name]`.

![8.png](image/8.png)
>Остановка докера

Проверим, что контейнер остановился через `docker ps`.

![9.png](image/9.png)
>Проверка остановки

Запустим докер с портами `80` и `443` в контейнере, замапленными на такие же порты на локальной машине, через команду `run`.

![10.png](image/10.png)
>Проверка остановки

Проверим, что в браузере по адресу `localhost:80` доступна стартовая страница `nginx`.

![11.png](image/11.png)
>Страница `localhost:80`

Перезапустим докер контейнер через `docker restart [container_id|container_name]`.

![12.png](image/12.png)
>Перезапуск докер контейнера

Проверим любым способом, что контейнер запустился.

![13.png](image/13.png)
>Выполнение команды `docker ps`

![14.png](image/14.png)
>Страница `localhost:80`

## Part 2. Операции с контейнером

Прочитаем конфигурационный файл `nginx.conf` внутри докер контейнера через команду `exec`.

![15.png](image/15.png)
>Прочитаем файл `nginx.conf`

Создадим на локальной машине файл `nginx.conf`. Настроим в нем по пути `/status` отдачу страницы статуса сервера `nginx`. Закомментируем строку `#include /etc/nginx/conf.d/*.conf;` и добавим блок `server`, в которой укажем путь `/status`

![16.png](image/16.png)
>Создадим файл

Скопируем созданный файл `nginx.conf` внутрь докер-образа через команду `docker cp`.

![17.png](image/17.png)
>Скопируем созданный файл

Перезапустим `nginx` внутри докер-образа через команду `exec`.

![18.png](image/18.png)
>Перезапустим `nginx`

Проверим, что по адресу `localhost:80/status` отдается страничка со статусом сервера `nginx`.

![19.png](image/19.png)
>`localhost:80/status`

Экспортируем контейнер в файл `container.tar` через команду `export`.

![20.png](image/20.png)
>Экспортируем контейнер в файл `container.tar`

Остановим контейнер.

![21.png](image/21.png)
>Остановка

Удалим образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры.

![22.png](image/22.png)
>Удаление образа, не удаляя перед этим контейнеры

Удалим остановленный контейнер.

![23.png](image/23.png)
>Удаление контейнера

Импортируем контейнер обратно через команду `import`.

![24.png](image/24.png)
>Импорт контейнера

Запустим импортированный контейнер.

![25.png](image/25.png)
>Запуск

Проверим, что по адресу `localhost:80/status` отдается страничка со статусом сервера `nginx`.

![26.png](image/26.png)
>`localhost:80/status`

## Part 3. Мини веб-сервер

Напишем мини-сервер на `C` и `FastCgi`, который будет возвращать простейшую страничку с надписью `Hello World!`.

![27.png](image/27.png)
>Код мини-сервера

Запустим написанный мини-сервер через `spawn-fcgi` на порту `8080`.

![28.png](image/28.png)
>Запуск мини-сервера 

Напишем свой nginx.conf, который будет проксировать все запросы с `81` порта на `127.0.0.1:8080`.

![29.png](image/29.png)
>Указание порта и IP в nginx.conf

Проверим, что в браузере по `localhost:81` отдается написанная тобой страничка.

![30.png](image/30.png)
>`localhost:81`

Но для того, чтобы запустить мини-сервер, я приложила немного больше усилий. Изначально я скачала докер образ через `docker pull nginx` и запустила контейнер с портом 81

![31.png](image/31.png)
>Скачивание и запуск докер-образа

Скопировала созданные файлы в контейнер с помощью `docker cp`

![32.png](image/32.png)
>Скопировала созданные файлы

Зашла в контейнер с использованием оболочки bash и обновила систему с помощью `apt-get upadte`

![33.png](image/33.png)
>Обновление системы

Скомпилировала наш мини-сервер 

![34.png](image/34.png)
>Компиляция мини-сервера

Запустила написанный мини-сервер через `spawn-fcgi` на порту `8080`

![35.png](image/35.png)
>Запуск мини-сервера

И затем уже открывается страница `localhost:81`, скриншот которой выше.

## Part 4. Свой докер

Напишем свой докер-образ, который:

1) собирает исходники мини сервера на FastCgi из Части 3;

2) запускает его на 8080 порту;

3) копирует внутрь образа написанный ./nginx/nginx.conf;

4) запускает nginx.

![36.png](image/36.png)
>Код докер-образа

Соберем написанный докер-образ через `docker build` при этом указав имя и тег. 

- Флаг `-t` позволяет назначить тег созданному образу для удобного обращения и версиирования.

![37.png](image/37.png)
>Сборка докер-образа

![38.png](image/38.png)
>Успешное завершение сборки докер-образа

Проверим через `docker images`, что все собралось корректно.

![39.png](image/39.png)
>Демонстрация `docker images`

Запустим собранный докер-образ с маппингом `81` порта на `80` на локальной машине и маппингом папки `./nginx` внутрь контейнера по адресу, где лежат конфигурационные файлы nginx'а. 

- `-i` — Этот флаг означает, что Docker будет работать в интерактивном режиме. Он сохраняет открытым стандартный ввод контейнера. Обычно используется совместно с флагом -t для работы с терминалом.

- `-t` — Этот флаг создаёт псевдотерминал (TTY) для контейнера. В сочетании с -i делает возможной работу с терминалом внутри контейнера. Это нужно для того, чтобы контейнер был доступен через консольный интерфейс, например, для ручного ввода команд.

- `-d` — (фоновый режим) Запускает контейнер в фоновом режиме, то есть он продолжает работать в фоне, а не блокирует терминал.

![40.png](image/40.png)
>Запуск

Проверим, что по `localhost:80` доступна страничка написанного мини сервера.

![41.png](image/41.png)
>`localhost:80`

Допишем в `./nginx/nginx.conf` проксирование странички `/status`, по которой надо отдавать статус сервера `nginx`.

![42.png](image/42.png)
>Переписывание `nginx.conf`

Перезапустим докер-образ.

![43.png](image/43.png)
>Перезапуск

Проверим, что теперь по `localhost:80/status` отдается страничка со статусом `nginx`

![44.png](image/44.png)
>`localhost:80/status`

## Part 5. Dockle

Установим Dockle с помощью ввода в терминал

> `VERSION=$(
 curl --silent "https://api.github.com/repos/goodwithtech/dockle/releases/latest" | \
 grep '"tag_name":' | \
 sed -E 's/.*"v([^"]+)".*/\1/' \
) && curl -L -o dockle.deb https://github.com/goodwithtech/dockle/releases/download/v${VERSION}/dockle_${VERSION}_Linux-64bit.deb`

А затем 

> sudo dpkg -i dockle.deb && rm dockle.deb

Просканируем образ из предыдущего задания через `dockle [image_id|repository]`.

![45.png](image/45.png)
>Образ из прошлого задания

Чтобы решить конфликты, необходимо очищать кэш apt-get и создать пользователя для контейнера.

![46.png](image/46.png)
>Новый докер-образ

Теперь снова запустим Dockle для проверки. 

![47.png](image/47.png)
>Демонстрация исправленных конфликтов

> Ошибка CIS-DI-0010 связана с тем, что последня версия nginx не рекомендует хранить ключи и другие конфиденциальные данные в контейнере, так как это может привести к утечкам. Данная проблема у меня не решилась с помощью применения ключей -ak при запуске команды Dockle, а так же не решилась с перемещением ключей из контейнера, поэтому я запускала Dockle c игнорированием данной ошибки

## Part 6. Базовый Docker Compose

Напишем файл `docker-compose.yml`, с помощью которого:

1) Поднимем докер-контейнер из Части 5 (он должен работать в локальной сети, т. е. не нужно использовать инструкцию EXPOSE и мапить порты на локальную машину).

2) Поднимем докер-контейнер с nginx, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.

3) Замапим 8080 порт второго контейнера на 80 порт локальной машины.

>Маппинг решила добавить сразу в `docker-compose`

![48.png](image/48.png)
>Файл `docker-compose`

Остановим все запущенные контейнеры.

![49.png](image/48.png)
>Файл `docker-compose`

Соберем и запустим проект с помощью команд `docker-compose build` и `docker-compose up`.

![50.png](image/50.png)
>Команда `docker-compose`

Проверим, что в браузере по `localhost:80` отдается написанная страничка, как и ранее.

![51.png](image/51.png)
>Команда `docker-compose`


